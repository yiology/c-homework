
## 题目回顾
```C
char f(char (*pp)[5]) { return pp[1][2]; }

int main() {
    char *B[20];
    f(B);
    return 0;
}
```
## 题目分析

函数 f 接收的参数类型是 char (*)[5]，即指向“含有5个字符的数组”的指针。

main 函数中定义的 B 类型是 char *B[20]，即含有20个“字符指针”的数组。当 B 作为参数传递时，它退化为 char **（二级指针）。

编译器会报 Warning，因为 char ** 和 char (*)[5] 的步长完全不同。

假设数组 B 的起始地址为 $X$。

在函数 f 内部，编译器认为 pp 指向的是长度为 5 的数组。

执行 pp[1] 时，指针向后移动 1 个单位步长。此时步长是 sizeof(char[5])，即 5 字节。

执行 pp[1][2] 时，在上述基础上再移动 2 个 char 的偏移，即 2 字节。

最终地址：$X + 5 + 2 = X + 7$。

由于 main 中的 B 实际上是一个指针数组，在 64 位系统下，每个指针占 8 字节。

地址 $X + 7$ 恰好落在第一个指针 B[0] 的第 8 个字节上。

因此，f 的返回值是 内存地址 $X + 7$ 处存放的原始字节数据。
